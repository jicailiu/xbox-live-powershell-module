//-----------------------------------------------------------------------
// <copyright file="CryptoExtensions.cs" company="Microsoft">
//     Copyright (c) Microsoft. All rights reserved.
//     Internal use only.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.IO;
using System.Security.Cryptography;

namespace SessionHistoryViewer
{
    public static class CryptoExtensions
    {
        /// <summary>
        /// AppDomain level RandomNumberGenerator instance
        /// </summary>
        private static RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create();

        /// <summary>
        /// Create a byte Randomly generated byte array
        /// </summary>
        /// <param name="size">Size of the byte array</param>
        /// <returns>Byte array with randomly generated elements</returns>
        public static byte[] CreateByteArray(int size)
        {
            var bytes = new byte[size];
            randomNumberGenerator.GetBytes(bytes);
            return bytes;
        }

        /// <summary>
        /// Use a ICryptoTransform instance to do a Symmetric Encryption pass on a byte array and return the Encrypted cipher
        /// </summary>
        /// <param name="encryptor">Instance of ICryptoTransform</param>
        /// <param name="secret">Secret to encrypt</param>
        /// <returns>Encrypted Secret</returns>
        public static byte[] Encrypt(this ICryptoTransform encryptor, byte[] secret)
        {
            if (encryptor == null)
            {
                throw new ArgumentNullException("encryptor");
            }

            if (secret == null)
            {
                throw new ArgumentNullException("secret");
            }

            // Either get a CA2202 error for possible disposing twice (handled by MemoryStream) or get a CA2000 error for not disposing
            using (var ms = new MemoryStream())
            {
                using (var cryptoStream = new CryptoStream(ms, encryptor, CryptoStreamMode.Write))
                {
                    byte[] encryptedBytes = null;
                    cryptoStream.Write(secret, 0, secret.Length);
                    cryptoStream.FlushFinalBlock();
                    encryptedBytes = ms.ToArray();
                    return encryptedBytes;
                }
            }
        }

        /// <summary>
        /// Use a ICryptoTransform instance to do a Symmetric Encryption pass on a byte array and return the Encrypted cipher
        /// </summary>
        /// <param name="decryptor">Instance of ICryptoTransform</param>
        /// <param name="cipher">Encrypted byte array</param>
        /// <returns>Decrypted byte array</returns>
        public static byte[] Decrypt(this ICryptoTransform decryptor, byte[] cipher)
        {
            if (decryptor == null)
            {
                throw new ArgumentNullException("decryptor");
            }

            if (cipher == null)
            {
                throw new ArgumentNullException("cipher");
            }

            // Either get a CA2202 error for possible disposing twice (handled by MemoryStream) or get a CA2000 error for not disposing
            using (var ms = new MemoryStream(cipher))
            {
                using (var cryptoStream = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
                {
                    byte[] decryptedBytes = new byte[cipher.Length];
                    var count = cryptoStream.Read(decryptedBytes, 0, decryptedBytes.Length);
                    byte[] result = new byte[count];
                    Array.Copy(decryptedBytes, 0, result, 0, count);
                    return result;
                }
            }
        }

        /// <summary>
        /// Computes a SHA1 Hash for a given byte array
        /// </summary>
        /// <param name="value">Byte array instance</param>
        /// <returns>SHA1 signature</returns>
        public static byte[] ComputeSHA1Hash(this byte[] value)
        {
            if (value == null)
            {
                return null;
            }

            using (SHA1Managed sha1 = new SHA1Managed())
            {
                return sha1.ComputeHash(value);
            }
        }

        /// <summary>
        /// Compute the SHA256 Hash for a given byte array.  The hash of a null/empty byte array is an empty array
        /// </summary>
        /// <param name="value">Byte array to hash</param>
        /// <returns>SHA256 Hash</returns>
        public static byte[] ComputeSHA256Hash(this byte[] value)
        {
            using (SHA256CryptoServiceProvider csp = new SHA256CryptoServiceProvider())
            {
                return value.ComputeSHA256Hash(csp);
            }
        }

        /// <summary>
        /// Compute the SHA256 Hash for a given byte array.  The hash of a null/empty byte array is an empty array
        /// </summary>
        /// <param name="value">Byte array to hash</param>
        /// <param name="csp">SHA256CryptoServiceProvider instance to use for the Hash</param>
        /// <returns>SHA256 Hash</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", MessageId = "0", Justification = "Parameter value may be null.")]
        public static byte[] ComputeSHA256Hash(this byte[] value, SHA256CryptoServiceProvider csp)
        {
            if (csp == null)
            {
                throw new ArgumentNullException("csp");
            }

            byte[] result = null;
            if (value != null || value.Length == 0)
            {
                result = csp.ComputeHash(value);
            }
            else
            {
                result = new byte[0];
            }

            return result;
        }
    }

    public static class AesCrypto
    {
        /// <summary>
        /// Create a randomly generated AES Key/IV for a given keysize
        /// </summary>
        /// <param name="keysize">AES Keysize</param>
        /// <param name="sparseIV">Determine whether or not to use a Sparse IV</param>
        /// <param name="key">Aes Key used for Encryption/Decryption</param>
        /// <param name="iv">Aes IV used for Encryption/Decryption</param>
        public static void CreateAesParameters(int keysize, bool sparseIV, out byte[] key, out byte[] iv)
        {
            if (keysize != 128 && keysize != 192 && keysize != 256)
            {
                throw new ArgumentException("Invalid keysize", "keysize");
            }

            key = CryptoExtensions.CreateByteArray(keysize / 8);
            iv = sparseIV ? new byte[16] : CryptoExtensions.CreateByteArray(16);
        }

        /// <summary>
        /// Encrypt a byte array with a key/iv pair
        /// </summary>
        /// <param name="secret">byte to encrypt</param>
        /// <param name="key">Aes Key used for Encryption/Decryption</param>
        /// <param name="iv">Aes IV used for Encryption/Decryption</param>
        /// <returns>Encrypted Byte Array</returns>
        public static byte[] Encrypt(byte[] secret, byte[] key, byte[] iv)
        {
            if (secret == null)
            {
                throw new ArgumentNullException("secret");
            }

            using (RijndaelManaged symmetricKey = new RijndaelManaged())
            {
                symmetricKey.Mode = CipherMode.CBC;
                using (var encryptor = symmetricKey.CreateEncryptor(key, iv))
                {
                    return encryptor.Encrypt(secret);
                }
            }
        }

        /// <summary>
        /// Decrypt a byte array for a Aes Key/IV Pair
        /// </summary>
        /// <param name="cipher">Encrypted Byte Array</param>
        /// <param name="key">Aes Key used for Encryption/Decryption</param>
        /// <param name="iv">Aes IV used for Encryption/Decryption</param>
        /// <returns>Decrypted Byte Array</returns>
        public static byte[] Decrypt(byte[] cipher, byte[] key, byte[] iv)
        {
            if (cipher == null)
            {
                throw new ArgumentNullException("cipher");
            }

            using (RijndaelManaged symmetricKey = new RijndaelManaged())
            {
                symmetricKey.Mode = CipherMode.CBC;
                byte[] plainTextBytes = new byte[cipher.Length];
                using (var decryptor = symmetricKey.CreateDecryptor(key, iv))
                {
                    return decryptor.Decrypt(cipher);
                }
            }
        }
    }
    public static class RSACrypto
    {
        /// <summary>
        /// Creates a PublicKey used for Encryption
        /// </summary>
        /// <param name="publicExponent">Public Exponent used in RSA</param>
        /// <param name="modulus">RSA Modulus:  this also informs the RSA keysize</param>
        /// <returns>RSACryptoServiceProvider instance that can be used to Encrypt data</returns>
        public static RSACryptoServiceProvider CreatePublicKey(uint publicExponent, byte[] modulus)
        {
            if (modulus == null)
            {
                throw new ArgumentNullException("modulus");
            }

            var rsa = new RSACryptoServiceProvider();
            rsa.ImportParameters(new RSAParameters
            {
                Modulus = modulus,
                Exponent = publicExponent.ConvertToPublicExponentBytes()
            });
            return rsa;
        }

        /// <summary>
        /// Alternative to BitConverter.GetBytes, converts a UInt32 to a byte array only requiring the neccessary bytes (e.g. 65537 returns {0x1,0x0,0x1} instead of {0x1,0x0,0x1,0x0}
        /// </summary>
        /// <param name="value">UInt32 value</param>
        /// <returns>byte array representing the Uint32</returns>
        public static byte[] ConvertToPublicExponentBytes(this uint value)
        {
            byte[] result = null;
            if (value >= 0x1000000)
            {
                result = new byte[4];
            }
            else if (value >= 0x10000)
            {
                result = new byte[3];
            }
            else if (value >= 0x100)
            {
                result = new byte[2];
            }
            else
            {
                result = new byte[1];
            }

            int idx = 0;
            while (value > 0)
            {
                result[idx++] = (byte)(value & 0xFF);
                value = value >> 8;
            }

            return result;
        }

        /// <summary>
        /// Converts an arbitrary sized byte array of no more than 32 bits and converts it to a UInt32
        /// </summary>
        /// <param name="value">Byte array instance</param>
        /// <returns>UInt32 value</returns>
        public static uint ConvertFromPublicExponentBytes(this byte[] value)
        {
            if (value == null)
            {
                throw new ArgumentNullException("value");
            }

            if (value.Length > 4)
            {
                throw new ArgumentException("UInt32 values are limited to four bytes", "value");
            }

            uint result = 0;

            for (int i = value.Length - 1; i >= 0; i--)
            {
                result = result << 8;
                result |= (uint)value[i];
            }

            return result;
        }
    }

}